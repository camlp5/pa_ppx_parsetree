diff -Bwiu --recursive parsing-5.0.0/ast_mapper.ml parsing-4.14.0/ast_mapper.ml
--- parsing-5.0.0/ast_mapper.ml	2023-04-09 23:34:40.399776507 -0700
+++ parsing-4.14.0/ast_mapper.ml	2023-04-09 23:34:55.236272466 -0700
@@ -843,7 +843,7 @@
         lid "principal", make_bool !Clflags.principal;
         lid "transparent_modules", make_bool !Clflags.transparent_modules;
         lid "unboxed_types", make_bool !Clflags.unboxed_types;
-        lid "unsafe_string", make_bool false; (* kept for compatibility *)
+        lid "unsafe_string", make_bool !Clflags.unsafe_string;
         get_cookies ()
       ]
     in
@@ -903,16 +903,7 @@
       | "include_dirs" ->
           Clflags.include_dirs := get_list get_string payload
       | "load_path" ->
-          (* Duplicates Compmisc.auto_include, since we can't reference Compmisc
-             from this module. *)
-          let auto_include find_in_dir fn =
-            if !Clflags.no_std_include then
-              raise Not_found
-            else
-              let alert = Location.auto_include_alert in
-              Load_path.auto_include_otherlibs alert find_in_dir fn
-          in
-          Load_path.init ~auto_include (get_list get_string payload)
+          Load_path.init (get_list get_string payload)
       | "open_modules" ->
           Clflags.open_modules := get_list get_string payload
       | "for_package" ->
@@ -932,6 +923,8 @@
           Clflags.transparent_modules := get_bool payload
       | "unboxed_types" ->
           Clflags.unboxed_types := get_bool payload
+      | "unsafe_string" ->
+          Clflags.unsafe_string := get_bool payload
       | "cookies" ->
           let l = get_list (get_pair get_string (fun x -> x)) payload in
           cookies :=
diff -Bwiu --recursive parsing-5.0.0/lexer.mli parsing-4.14.0/lexer.mli
--- parsing-5.0.0/lexer.mli	2023-04-09 23:34:40.399776507 -0700
+++ parsing-4.14.0/lexer.mli	2023-04-09 23:34:55.236272466 -0700
@@ -35,11 +35,12 @@
   | Keyword_as_label of string
   | Invalid_literal of string
   | Invalid_directive of string * string option
+;;
 
 exception Error of error * Location.t
 
-val in_comment : unit -> bool
-val in_string : unit -> bool
+val in_comment : unit -> bool;;
+val in_string : unit -> bool;;
 
 
 val print_warnings : bool ref
diff -Bwiu --recursive parsing-5.0.0/lexer.mll parsing-4.14.0/lexer.mll
--- parsing-5.0.0/lexer.mll	2023-04-09 23:34:40.399776507 -0700
+++ parsing-4.14.0/lexer.mll	2023-04-09 23:34:55.236272466 -0700
@@ -31,8 +31,9 @@
   | Keyword_as_label of string
   | Invalid_literal of string
   | Invalid_directive of string * string option
+;;
 
-exception Error of error * Location.t
+exception Error of error * Location.t;;
 
 (* The table of keywords *)
 
@@ -110,9 +111,9 @@
 let store_lexeme lexbuf = store_string (Lexing.lexeme lexbuf)
 
 (* To store the position of the beginning of a string and comment *)
-let string_start_loc = ref Location.none
-let comment_start_loc = ref []
-let in_comment () = !comment_start_loc <> []
+let string_start_loc = ref Location.none;;
+let comment_start_loc = ref [];;
+let in_comment () = !comment_start_loc <> [];;
 let is_in_string = ref false
 let in_string () = !is_in_string
 let print_warnings = ref true
@@ -246,6 +247,7 @@
     pos_lnum = if absolute then line else pos.pos_lnum + line;
     pos_bol = pos.pos_cnum - chars;
   }
+;;
 
 let preprocessor = ref None
 
diff -Bwiu --recursive parsing-5.0.0/location.ml parsing-4.14.0/location.ml
--- parsing-5.0.0/location.ml	2023-04-09 23:34:40.399776507 -0700
+++ parsing-4.14.0/location.ml	2023-04-09 23:34:55.236272466 -0700
@@ -16,18 +16,21 @@
 open Lexing
 
 type t = Warnings.loc =
-  { loc_start: position; loc_end: position; loc_ghost: bool }
+  { loc_start: position; loc_end: position; loc_ghost: bool };;
 
-let in_file = Warnings.ghost_loc_in_file
+let in_file name =
+  let loc = { dummy_pos with pos_fname = name } in
+  { loc_start = loc; loc_end = loc; loc_ghost = true }
+;;
 
-let none = in_file "_none_"
-let is_none l = (l = none)
+let none = in_file "_none_";;
+let is_none l = (l = none);;
 
 let curr lexbuf = {
   loc_start = lexbuf.lex_start_p;
   loc_end = lexbuf.lex_curr_p;
   loc_ghost = false
-}
+};;
 
 let init lexbuf fname =
   lexbuf.lex_curr_p <- {
@@ -36,34 +39,36 @@
     pos_bol = 0;
     pos_cnum = 0;
   }
+;;
 
 let symbol_rloc () = {
   loc_start = Parsing.symbol_start_pos ();
   loc_end = Parsing.symbol_end_pos ();
   loc_ghost = false;
-}
+};;
 
 let symbol_gloc () = {
   loc_start = Parsing.symbol_start_pos ();
   loc_end = Parsing.symbol_end_pos ();
   loc_ghost = true;
-}
+};;
 
 let rhs_loc n = {
   loc_start = Parsing.rhs_start_pos n;
   loc_end = Parsing.rhs_end_pos n;
   loc_ghost = false;
-}
+};;
 
 let rhs_interval m n = {
   loc_start = Parsing.rhs_start_pos m;
   loc_end = Parsing.rhs_end_pos n;
   loc_ghost = false;
-}
+};;
 
 (* return file, line, char from the given position *)
 let get_pos_info pos =
   (pos.pos_fname, pos.pos_lnum, pos.pos_cnum - pos.pos_bol)
+;;
 
 type 'a loc = {
   txt : 'a;
@@ -895,32 +900,6 @@
 let deprecated ?def ?use loc message =
   alert ?def ?use ~kind:"deprecated" loc message
 
-let auto_include_alert lib =
-  let message = Printf.sprintf "\
-    OCaml's lib directory layout changed in 5.0. The %s subdirectory has been \
-    automatically added to the search path, but you should add -I +%s to the \
-    command-line to silence this alert (e.g. by adding %s to the list of \
-    libraries in your dune file, or adding use_%s to your _tags file for \
-    ocamlbuild, or using -package %s for ocamlfind)." lib lib lib lib lib in
-  let alert =
-    {Warnings.kind="ocaml_deprecated_auto_include"; use=none; def=none;
-     message = Format.asprintf "@[@\n%a@]" Format.pp_print_text message}
-  in
-  prerr_alert none alert
-
-let deprecated_script_alert program =
-  let message = Printf.sprintf "\
-    Running %s where the first argument is an implicit basename with no \
-    extension (e.g. %s script-file) is deprecated. Either rename the script \
-    (%s script-file.ml) or qualify the basename (%s ./script-file)"
-    program program program program
-  in
-  let alert =
-    {Warnings.kind="ocaml_deprecated_cli"; use=none; def=none;
-     message = Format.asprintf "@[@\n%a@]" Format.pp_print_text message}
-  in
-  prerr_alert none alert
-
 (******************************************************************************)
 (* Reporting errors on exceptions *)
 
diff -Bwiu --recursive parsing-5.0.0/location.mli parsing-4.14.0/location.mli
--- parsing-5.0.0/location.mli	2023-04-09 23:34:40.399776507 -0700
+++ parsing-4.14.0/location.mli	2023-04-09 23:34:55.236272466 -0700
@@ -243,13 +243,6 @@
 val alert: ?def:t -> ?use:t -> kind:string -> t -> string -> unit
 (** Prints an arbitrary alert. *)
 
-val auto_include_alert: string -> unit
-(** Prints an alert that -I +lib has been automatically added to the load
-    path *)
-
-val deprecated_script_alert: string -> unit
-(** [deprecated_script_alert command] prints an alert that [command foo] has
-    been deprecated in favour of [command ./foo] *)
 
 (** {1 Reporting errors} *)
 
diff -Bwiu --recursive parsing-5.0.0/parse.ml parsing-4.14.0/parse.ml
--- parsing-5.0.0/parse.ml	2023-04-09 23:34:40.403776641 -0700
+++ parsing-4.14.0/parse.ml	2023-04-09 23:34:55.236272466 -0700
@@ -140,12 +140,6 @@
         "broken invariant in parsetree: %s" s
   | Invalid_package_type (loc, s) ->
       Location.errorf ~loc "invalid package type: %s" s
-  | Removed_string_set loc ->
-      Location.errorf ~loc
-        "Syntax error: strings are immutable, there is no assignment \
-         syntax for them.\n\
-         Hint: Mutable sequences of bytes are available in the Bytes module.\n\
-         Hint: Did you mean to use 'Bytes.set'?"
 
 let () =
   Location.register_error_of_exn
diff -Bwiu --recursive parsing-5.0.0/parser.mly parsing-4.14.0/parser.mly
--- parsing-5.0.0/parser.mly	2023-04-09 23:34:40.403776641 -0700
+++ parsing-4.14.0/parser.mly	2023-04-09 23:34:55.236272466 -0700
@@ -98,13 +98,13 @@
 
 let reloc_pat ~loc x =
   { x with ppat_loc = make_loc loc;
-           ppat_loc_stack = push_loc x.ppat_loc x.ppat_loc_stack }
+           ppat_loc_stack = push_loc x.ppat_loc x.ppat_loc_stack };;
 let reloc_exp ~loc x =
   { x with pexp_loc = make_loc loc;
-           pexp_loc_stack = push_loc x.pexp_loc x.pexp_loc_stack }
+           pexp_loc_stack = push_loc x.pexp_loc x.pexp_loc_stack };;
 let reloc_typ ~loc x =
   { x with ptyp_loc = make_loc loc;
-           ptyp_loc_stack = push_loc x.ptyp_loc x.ptyp_loc_stack }
+           ptyp_loc_stack = push_loc x.ptyp_loc x.ptyp_loc_stack };;
 
 let mkexpvar ~loc (name : string) =
   mkexp ~loc (Pexp_ident(mkrhs (Lident name) loc))
@@ -230,9 +230,6 @@
 let expecting loc nonterm =
     raise Syntaxerr.(Error(Expecting(make_loc loc, nonterm)))
 
-let removed_string_set loc =
-  raise(Syntaxerr.Error(Syntaxerr.Removed_string_set(make_loc loc)))
-
 (* Using the function [not_expecting] in a semantic action means that this
    syntactic form is recognized by the parser but is in fact incorrect. This
    idiom is used in a few places to produce ad hoc syntax error messages. *)
@@ -307,9 +304,7 @@
   let opname = if !Clflags.unsafe then "unsafe_" ^ opname else opname in
   let prefix = match paren_kind with
     | Paren -> Lident "Array"
-    | Bracket ->
-        if assign then removed_string_set loc
-        else Lident "String"
+    | Bracket -> Lident "String"
     | Brace ->
        let submodule_name = match n with
          | One -> "Array1"
diff -Bwiu --recursive parsing-5.0.0/pprintast.ml parsing-4.14.0/pprintast.ml
--- parsing-5.0.0/pprintast.ml	2023-04-09 23:34:40.403776641 -0700
+++ parsing-4.14.0/pprintast.ml	2023-04-09 23:34:55.236272466 -0700
@@ -28,7 +28,7 @@
 open Parsetree
 open Ast_helper
 
-let prefix_symbols  = [ '!'; '?'; '~' ]
+let prefix_symbols  = [ '!'; '?'; '~' ] ;;
 let infix_symbols = [ '='; '<'; '>'; '@'; '^'; '|'; '&'; '+'; '-'; '*'; '/';
                       '$'; '%'; '#' ]
 
@@ -1068,17 +1068,19 @@
 
 and with_constraint ctxt f = function
   | Pwith_type (li, ({ptype_params= ls ;_} as td)) ->
+      let ls = List.map fst ls in
       pp f "type@ %a %a =@ %a"
-        (type_params ctxt) ls
-        longident_loc li (type_declaration ctxt) td
+        (list (core_type ctxt) ~sep:"," ~first:"(" ~last:")")
+        ls longident_loc li (type_declaration ctxt) td
   | Pwith_module (li, li2) ->
       pp f "module %a =@ %a" longident_loc li longident_loc li2;
   | Pwith_modtype (li, mty) ->
       pp f "module type %a =@ %a" longident_loc li (module_type ctxt) mty;
   | Pwith_typesubst (li, ({ptype_params=ls;_} as td)) ->
+      let ls = List.map fst ls in
       pp f "type@ %a %a :=@ %a"
-        (type_params ctxt) ls
-        longident_loc li
+        (list (core_type ctxt) ~sep:"," ~first:"(" ~last:")")
+        ls longident_loc li
         (type_declaration ctxt) td
   | Pwith_modsubst (li, li2) ->
       pp f "module %a :=@ %a" longident_loc li longident_loc li2
diff -Bwiu --recursive parsing-5.0.0/printast.ml parsing-4.14.0/printast.ml
--- parsing-5.0.0/printast.ml	2023-04-09 23:34:40.403776641 -0700
+++ parsing-4.14.0/printast.ml	2023-04-09 23:34:55.236272466 -0700
@@ -13,11 +13,11 @@
 (*                                                                        *)
 (**************************************************************************)
 
-open Asttypes
-open Format
-open Lexing
-open Location
-open Parsetree
+open Asttypes;;
+open Format;;
+open Lexing;;
+open Location;;
+open Parsetree;;
 
 let fmt_position with_name f l =
   let fname = if with_name then l.pos_fname else "" in
@@ -25,6 +25,7 @@
   then fprintf f "%s[%d]" fname l.pos_cnum
   else fprintf f "%s[%d,%d+%d]" fname l.pos_lnum l.pos_bol
                (l.pos_cnum - l.pos_bol)
+;;
 
 let fmt_location f loc =
   if not !Clflags.locations then ()
@@ -34,24 +35,29 @@
                          (fmt_position p_2nd_name) loc.loc_end;
     if loc.loc_ghost then fprintf f " ghost";
   end
+;;
 
 let rec fmt_longident_aux f x =
   match x with
-  | Longident.Lident (s) -> fprintf f "%s" s
-  | Longident.Ldot (y, s) -> fprintf f "%a.%s" fmt_longident_aux y s
+  | Longident.Lident (s) -> fprintf f "%s" s;
+  | Longident.Ldot (y, s) -> fprintf f "%a.%s" fmt_longident_aux y s;
   | Longident.Lapply (y, z) ->
-      fprintf f "%a(%a)" fmt_longident_aux y fmt_longident_aux z
+      fprintf f "%a(%a)" fmt_longident_aux y fmt_longident_aux z;
+;;
 
-let fmt_longident f x = fprintf f "\"%a\"" fmt_longident_aux x
+let fmt_longident f x = fprintf f "\"%a\"" fmt_longident_aux x;;
 
 let fmt_longident_loc f (x : Longident.t loc) =
-  fprintf f "\"%a\" %a" fmt_longident_aux x.txt fmt_location x.loc
+  fprintf f "\"%a\" %a" fmt_longident_aux x.txt fmt_location x.loc;
+;;
 
 let fmt_string_loc f (x : string loc) =
-  fprintf f "\"%s\" %a" x.txt fmt_location x.loc
+  fprintf f "\"%s\" %a" x.txt fmt_location x.loc;
+;;
 
 let fmt_str_opt_loc f (x : string option loc) =
-  fprintf f "\"%s\" %a" (Option.value x.txt ~default:"_") fmt_location x.loc
+  fprintf f "\"%s\" %a" (Option.value x.txt ~default:"_") fmt_location x.loc;
+;;
 
 let fmt_char_option f = function
   | None -> fprintf f "None"
@@ -59,28 +65,32 @@
 
 let fmt_constant f x =
   match x with
-  | Pconst_integer (i,m) -> fprintf f "PConst_int (%s,%a)" i fmt_char_option m
-  | Pconst_char (c) -> fprintf f "PConst_char %02x" (Char.code c)
+  | Pconst_integer (i,m) -> fprintf f "PConst_int (%s,%a)" i fmt_char_option m;
+  | Pconst_char (c) -> fprintf f "PConst_char %02x" (Char.code c);
   | Pconst_string (s, strloc, None) ->
-      fprintf f "PConst_string(%S,%a,None)" s fmt_location strloc
+      fprintf f "PConst_string(%S,%a,None)" s fmt_location strloc ;
   | Pconst_string (s, strloc, Some delim) ->
-      fprintf f "PConst_string (%S,%a,Some %S)" s fmt_location strloc delim
-  | Pconst_float (s,m) -> fprintf f "PConst_float (%s,%a)" s fmt_char_option m
+      fprintf f "PConst_string (%S,%a,Some %S)" s fmt_location strloc delim;
+  | Pconst_float (s,m) -> fprintf f "PConst_float (%s,%a)" s fmt_char_option m;
+;;
 
 let fmt_mutable_flag f x =
   match x with
-  | Immutable -> fprintf f "Immutable"
-  | Mutable -> fprintf f "Mutable"
+  | Immutable -> fprintf f "Immutable";
+  | Mutable -> fprintf f "Mutable";
+;;
 
 let fmt_virtual_flag f x =
   match x with
-  | Virtual -> fprintf f "Virtual"
-  | Concrete -> fprintf f "Concrete"
+  | Virtual -> fprintf f "Virtual";
+  | Concrete -> fprintf f "Concrete";
+;;
 
 let fmt_override_flag f x =
   match x with
-  | Override -> fprintf f "Override"
-  | Fresh -> fprintf f "Fresh"
+  | Override -> fprintf f "Override";
+  | Fresh -> fprintf f "Fresh";
+;;
 
 let fmt_closed_flag f x =
   match x with
@@ -89,46 +99,53 @@
 
 let fmt_rec_flag f x =
   match x with
-  | Nonrecursive -> fprintf f "Nonrec"
-  | Recursive -> fprintf f "Rec"
+  | Nonrecursive -> fprintf f "Nonrec";
+  | Recursive -> fprintf f "Rec";
+;;
 
 let fmt_direction_flag f x =
   match x with
-  | Upto -> fprintf f "Up"
-  | Downto -> fprintf f "Down"
+  | Upto -> fprintf f "Up";
+  | Downto -> fprintf f "Down";
+;;
 
 let fmt_private_flag f x =
   match x with
-  | Public -> fprintf f "Public"
-  | Private -> fprintf f "Private"
+  | Public -> fprintf f "Public";
+  | Private -> fprintf f "Private";
+;;
 
 let line i f s (*...*) =
   fprintf f "%s" (String.make ((2*i) mod 72) ' ');
   fprintf f s (*...*)
+;;
 
 let list i f ppf l =
   match l with
-  | [] -> line i ppf "[]\n"
+  | [] -> line i ppf "[]\n";
   | _ :: _ ->
      line i ppf "[\n";
      List.iter (f (i+1) ppf) l;
-     line i ppf "]\n"
+     line i ppf "]\n";
+;;
 
 let option i f ppf x =
   match x with
-  | None -> line i ppf "None\n"
+  | None -> line i ppf "None\n";
   | Some x ->
       line i ppf "Some\n";
-      f (i+1) ppf x
+      f (i+1) ppf x;
+;;
 
-let longident_loc i ppf li = line i ppf "%a\n" fmt_longident_loc li
-let string i ppf s = line i ppf "\"%s\"\n" s
-let string_loc i ppf s = line i ppf "%a\n" fmt_string_loc s
-let str_opt_loc i ppf s = line i ppf "%a\n" fmt_str_opt_loc s
+let longident_loc i ppf li = line i ppf "%a\n" fmt_longident_loc li;;
+let string i ppf s = line i ppf "\"%s\"\n" s;;
+let string_loc i ppf s = line i ppf "%a\n" fmt_string_loc s;;
+let str_opt_loc i ppf s = line i ppf "%a\n" fmt_str_opt_loc s;;
 let arg_label i ppf = function
   | Nolabel -> line i ppf "Nolabel\n"
   | Optional s -> line i ppf "Optional \"%s\"\n" s
   | Labelled s -> line i ppf "Labelled \"%s\"\n" s
+;;
 
 let typevars ppf vs =
   List.iter (fun x -> fprintf ppf " %a" Pprintast.tyvar x.txt) vs
@@ -936,6 +953,7 @@
   | Rinherit (ct) ->
       line i ppf "Rinherit\n";
       core_type (i+1) ppf ct
+;;
 
 let rec toplevel_phrase i ppf x =
   match x with
@@ -950,14 +968,15 @@
 
 and directive_argument i ppf x =
   match x.pdira_desc with
-  | Pdir_string (s) -> line i ppf "Pdir_string \"%s\"\n" s
-  | Pdir_int (n, None) -> line i ppf "Pdir_int %s\n" n
-  | Pdir_int (n, Some m) -> line i ppf "Pdir_int %s%c\n" n m
-  | Pdir_ident (li) -> line i ppf "Pdir_ident %a\n" fmt_longident li
-  | Pdir_bool (b) -> line i ppf "Pdir_bool %s\n" (string_of_bool b)
+  | Pdir_string (s) -> line i ppf "Pdir_string \"%s\"\n" s;
+  | Pdir_int (n, None) -> line i ppf "Pdir_int %s\n" n;
+  | Pdir_int (n, Some m) -> line i ppf "Pdir_int %s%c\n" n m;
+  | Pdir_ident (li) -> line i ppf "Pdir_ident %a\n" fmt_longident li;
+  | Pdir_bool (b) -> line i ppf "Pdir_bool %s\n" (string_of_bool b);
+;;
 
-let interface ppf x = list 0 signature_item ppf x
+let interface ppf x = list 0 signature_item ppf x;;
 
-let implementation ppf x = list 0 structure_item ppf x
+let implementation ppf x = list 0 structure_item ppf x;;
 
-let top_phrase ppf x = toplevel_phrase 0 ppf x
+let top_phrase ppf x = toplevel_phrase 0 ppf x;;
diff -Bwiu --recursive parsing-5.0.0/printast.mli parsing-4.14.0/printast.mli
--- parsing-5.0.0/printast.mli	2023-04-09 23:34:40.403776641 -0700
+++ parsing-4.14.0/printast.mli	2023-04-09 23:34:55.236272466 -0700
@@ -20,12 +20,12 @@
 
 *)
 
-open Parsetree
-open Format
+open Parsetree;;
+open Format;;
 
-val interface : formatter -> signature_item list -> unit
-val implementation : formatter -> structure_item list -> unit
-val top_phrase : formatter -> toplevel_phrase -> unit
+val interface : formatter -> signature_item list -> unit;;
+val implementation : formatter -> structure_item list -> unit;;
+val top_phrase : formatter -> toplevel_phrase -> unit;;
 
 val expression: int -> formatter -> expression -> unit
 val structure: int -> formatter -> structure -> unit
diff -Bwiu --recursive parsing-5.0.0/syntaxerr.ml parsing-4.14.0/syntaxerr.ml
--- parsing-5.0.0/syntaxerr.ml	2023-04-09 23:34:40.403776641 -0700
+++ parsing-4.14.0/syntaxerr.ml	2023-04-09 23:34:55.236272466 -0700
@@ -24,7 +24,6 @@
   | Other of Location.t
   | Ill_formed_ast of Location.t * string
   | Invalid_package_type of Location.t * string
-  | Removed_string_set of Location.t
 
 exception Error of error
 exception Escape_error
@@ -37,8 +36,7 @@
   | Not_expecting (l, _)
   | Ill_formed_ast (l, _)
   | Invalid_package_type (l, _)
-  | Expecting (l, _)
-  | Removed_string_set l -> l
+  | Expecting (l, _) -> l
 
 
 let ill_formed_ast loc s =
diff -Bwiu --recursive parsing-5.0.0/syntaxerr.mli parsing-4.14.0/syntaxerr.mli
--- parsing-5.0.0/syntaxerr.mli	2023-04-09 23:34:40.403776641 -0700
+++ parsing-4.14.0/syntaxerr.mli	2023-04-09 23:34:55.236272466 -0700
@@ -29,7 +29,6 @@
   | Other of Location.t
   | Ill_formed_ast of Location.t * string
   | Invalid_package_type of Location.t * string
-  | Removed_string_set of Location.t
 
 exception Error of error
 exception Escape_error
